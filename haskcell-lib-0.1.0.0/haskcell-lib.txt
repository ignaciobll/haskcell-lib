-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/ignaciobll/haskcell-lib#readme</a>
@package haskcell-lib
@version 0.1.0.0


-- | Módulo general para hojas de cálculo de la herramienta
--   <tt>haskcell</tt>.
module Data.SpreadSheet

-- | <a>SpreadSheet</a> representa la estructura de datos de una hoja de
--   cálculo.
--   
--   Las hojas cálculo pueden contener cualquier tipo de dato, pero solo
--   valores de dicho tipo. Es decir, no se podrán tener hojas de cálculo
--   heterogéneas que contengan valores <a>Double</a> o <a>Bool</a> a la
--   vez. Para una representación más cercana al uso ordinario de las hojas
--   de cálculo se recomienda mirar el módulo <a>Cell</a>.
--   
--   La implementación interna de esta estructura de datos es mediante un
--   diccionario (<a>Map</a> <a>Strict</a>) donde las claves son posiciones
--   (<a>Pos</a>).
--   
--   En este módulo se definen un conjunto de operaciones para la creación,
--   consulta y modificación de hojas de cálculo.
data SpreadSheet a
Mk :: Pos -> Pos -> Map Pos a -> SpreadSheet a
[topl] :: SpreadSheet a -> Pos
[botr] :: SpreadSheet a -> Pos
[mp] :: SpreadSheet a -> Map Pos a
Empty :: SpreadSheet a

-- | Posición de una celda en la hoja de cálculo. Comienzan en
--   <tt>(1,1)</tt>.
--   
--   Punto bidimensional en el que la primera coordenada corresponde a la
--   columna y la segunda a la fila.
--   
--   Ejemplo para localizar una celda:
--   
--   TODO: table
type Pos = (Natural, Natural)

-- | Un rango está definido por dos posiciones, la superior izquierda y la
--   inferior derecha.
--   
--   Es utilizado en la generación de rangos con la función <a>range</a>.
data Range
Range :: Pos -> Pos -> Range

-- | Hoja de cálculo vacía.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   </pre>
empty :: SpreadSheet a

-- | A partir de un solo valor, se genera la hoja que en la posición (1,1)
--   tiene dicho valor.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   Range (1,1) (1,1)
--   fromList [((1,1), True)]
--   </pre>
singleton :: a -> SpreadSheet a

-- | Generar una hoja con un valor en una posición.
--   
--   <pre>
--   &gt;&gt;&gt; singleton (1,5) True
--   Range (1,5) (1,5)
--   fromList [((1,5),True)]
--   </pre>
singletonPos :: Pos -> a -> SpreadSheet a

-- | De una lista de pares posición-valor se genera la hoja
--   correspondiente. En el caso de tener posiciones repetidas, permanecerá
--   la que tenga un índice mayor.
--   
--   <pre>
--   &gt;&gt;&gt; fromList [((1,1), 0), ((1,2), 1), ((1,1), 5)]
--   Range (1,1) (1,2)
--   fromList [((1,1),5),((1,2),3)]
--   </pre>
fromList :: [(Pos, a)] -> SpreadSheet a

-- | Transforma una hoja de cálculo a una lista que contiene sus valores.
--   
--   <pre>
--   &gt;&gt;&gt; toListValues empty == []
--   True
--   </pre>
--   
--   La función <a>toList</a> aplicada a esta esctructura de datos utiliza
--   esta función.
toListValues :: SpreadSheet a -> [a]

-- | Construcción de forma equivalente a <a>fromList</a>, salvo que se usa
--   un diccionario de la librearía <a>Map</a>.
--   
--   Destinado a construir la hoja de cálculo aprovechando las funciones
--   optimizadas para diccionarios. Las precondiciones de las funciones de
--   construcción de diccionarios no se comprueban, ya que forman parte de
--   otro módulo.
--   
--   <pre>
--   &gt;&gt;&gt; let cells = zipWith (,) [(x,y) | x &lt;- [1..9], y &lt;- [1..9]] [1..]
--   
--   &gt;&gt;&gt; Map.valid $ Map.fromAscList cells
--   True
--   
--   &gt;&gt;&gt; Map.valid $ Map.fromAscList (reverse cells)
--   False
--   
--   &gt;&gt;&gt; fromDict $ Map.fromAscList cells
--   Range (1,1) (9,9)
--   fromList [((1,1),1),((1,2),2),((1,3),3),((1,4),...
--   </pre>
fromDict :: Map Pos a -> SpreadSheet a

-- | Obtiene el valor de una posición (<a>Pos</a>) de una hoja de cálculo.
--   
--   Si la celda contiene un dato, devuelve el valor como (<a>Just</a>
--   <tt>valor</tt>). Si no existe, devuelve <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; get (1,1) $ fromList [((1,1), "valor")]
--   Just "valor"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; get (2,2) $ fromList [((1,1), "valor")]
--   Nothing
--   </pre>
get :: Pos -> SpreadSheet a -> Maybe a

-- | Dando un rango y una hoja de cálculo, genera una hoja de cálculo con
--   las celdas en dicho rango.
--   
--   <pre>
--   &gt;&gt;&gt; let cells = zipWith (,) [(x,y) | x &lt;- [1..9], y &lt;- [1..9]] [1..]
--   
--   &gt;&gt;&gt; range (Range (8,7) (9,9)) $ fromList cells
--   Range (8,7) (9,9)
--   fromList [((8,7),70),((8,8),71),((8,9),72),((9,7),79),((9,8),80),((9,9),81)]
--   </pre>
selectRange :: Range -> SpreadSheet a -> SpreadSheet a

-- | Selecciona las celdas con datos de una hoja de cálculo para una fila
--   dada.
--   
--   <pre>
--   &gt;&gt;&gt; let cells = zipWith (,) [(x,y) | x &lt;- [1..5], y &lt;- [1..5]] [1..]
--   
--   &gt;&gt;&gt; row 3 $ fromList cells
--   Range (1,3) (5,3)
--   fromList [((1,3),3),((2,3),8),((3,3),13),((4,3),18),((5,3),23)]
--   </pre>
row :: Natural -> SpreadSheet a -> SpreadSheet a

-- | Selecciona las celdas con datos de una hoja de cálculo para una
--   columna dada.
--   
--   <pre>
--   &gt;&gt;&gt; let cells = zipWith (,) [(x,y) | x &lt;- [1..5], y &lt;- [1..5]] [1..]
--   
--   &gt;&gt;&gt; column 2 $ fromList cells
--   Range (2,1) (2,5)
--   fromList [((2,1),6),((2,2),7),((2,3),8),((2,4),9),((2,5),10)]
--   </pre>
column :: Natural -> SpreadSheet a -> SpreadSheet a

-- | Genera una hoja de cálculo a partir de una dada según una función
--   discriminante sobre las posiciónes.
--   
--   En el siguiente ejemplo se eligen por ejemplo las celdas presentes en
--   la diagonal.
--   
--   <pre>
--   &gt;&gt;&gt; select (\(col,row) -&gt; col == row) $ fromList [((1,1), "a"), ((2,1), "b"), ((1,2), "c"), ((2,2), "d")]
--   Range (1,1) (2,2)
--   fromList [((1,1),"a"),((2,2),"d")]
--   </pre>
select :: (Pos -> Bool) -> SpreadSheet a -> SpreadSheet a

-- | Inserta en una posición un valor. Este valor se puede generar según
--   una función sobre una hoja de cálculo.
--   
--   Esta función permite la composición de sucesivas inserciones.
--   
--   <pre>
--   &gt;&gt;&gt; empty &amp; put (1,1) (const True) &amp; put (1,2) (const False)
--   Range (1,1) (1,2)
--   fromList [((1,1),True),((1,2),False)]
--   </pre>
put :: Pos -> (SpreadSheet a -> a) -> SpreadSheet a -> SpreadSheet a

-- | Combina dos hojas de cálculo. En el caso de que dos celdas contengan
--   datos en cada una de las dos hojas, dejará el dato de la segunda.
--   
--   También se puede usar el operador <tt>(&lt;&gt;)</tt> de la clase
--   <a>Semigroup</a>.
union :: SpreadSheet a -> SpreadSheet a -> SpreadSheet a

-- | Genera una hoja de cálculo nueva con la intersección de las celdas,
--   dejando los valores de la primera hoja.
intersection :: SpreadSheet a -> SpreadSheet a -> SpreadSheet a

-- | Operador para la intersección. Ver <a>intersection</a>.
(</>) :: SpreadSheet a -> SpreadSheet a -> SpreadSheet a

-- | La función <a>mapMaybe</a> está orientada a la selección de valores de
--   un tipo que puedan ser transformados a otro. Tomando una hoja de
--   cálculo se obtiene una nueva, con un tipo distinto, con solo aquellos
--   valores que han podido ser extraidos.
--   
--   Esta función tiene su ejemplo en el conjunto de funciónes
--   <a>extractDouble</a>, <a>extractString</a> o <a>extractDay</a> del
--   módulo <a>Cell</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let days = fromList [((1,1), "2018-12-23"), ((1,2),"-"), ((1,3),"2018-12-25")] :: SpreadSheet String
--   
--   &gt;&gt;&gt; let parseDay = (\x -&gt; parseTimeM True defaultTimeLocale "%Y-%-m-%-d" x) :: String -&gt; Maybe Day
--   
--   &gt;&gt;&gt; :t mapMaybe parseDay days
--   extract p days :: SpreadSheet Day
--   
--   &gt;&gt;&gt; mapMaybe parseDay days
--   Range (1,1) (1,3)
--   fromList [((1,1),2018-12-23),((1,3),2018-12-25)]
--   </pre>
mapMaybe :: (a -> Maybe b) -> SpreadSheet a -> SpreadSheet b

-- | Indica el número de columnas que tiene una hoja de cálculo.
width :: SpreadSheet a -> Maybe Natural

-- | Indica el número de filas que tiene una hoja de cálculo.
height :: SpreadSheet a -> Maybe Natural

-- | Indica el rango en el que están contenidos los valores de la hoja de
--   cálculo.
limits :: SpreadSheet a -> Maybe Range

-- | Enumera las columnas de la hoja de cálculo.
--   
--   <pre>
--   &gt;&gt;&gt; columns empty
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; columns $ fromList [((5,3), True), ((10,6), True)]
--   [5,6,7,8,9,10]
--   </pre>
columns :: SpreadSheet a -> [Natural]

-- | Enumera las filas de la hoja de cálculo.
--   
--   <pre>
--   &gt;&gt;&gt; rows empty
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rows $ fromList [((5,3), True), ((10,6), True)]
--   [3,4,5,6]
--   </pre>
rows :: SpreadSheet a -> [Natural]
instance GHC.Arr.Ix Data.SpreadSheet.Range
instance GHC.Classes.Ord Data.SpreadSheet.Range
instance GHC.Classes.Eq Data.SpreadSheet.Range
instance GHC.Show.Show Data.SpreadSheet.Range
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.SpreadSheet.SpreadSheet a)
instance GHC.Base.Functor Data.SpreadSheet.SpreadSheet
instance GHC.Base.Semigroup (Data.SpreadSheet.SpreadSheet a)
instance GHC.Base.Monoid (Data.SpreadSheet.SpreadSheet a)
instance Data.Foldable.Foldable Data.SpreadSheet.SpreadSheet
instance GHC.Show.Show a => GHC.Show.Show (Data.SpreadSheet.SpreadSheet a)

module Data.SpreadSheet.Date
data Month
January :: Month
February :: Month
March :: Month
April :: Month
May :: Month
June :: Month
July :: Month
August :: Month
September :: Month
October :: Month
November :: Month
December :: Month
data WeekDay
Monday :: WeekDay
Tuesday :: WeekDay
Wednesday :: WeekDay
Thursday :: WeekDay
Friday :: WeekDay
Saturday :: WeekDay
Sunday :: WeekDay
between :: Day -> Day -> Day -> Bool
next :: (Eq a, Bounded a, Enum a) => a -> a
getMonth :: Day -> Month
instance GHC.Read.Read Data.SpreadSheet.Date.WeekDay
instance GHC.Arr.Ix Data.SpreadSheet.Date.WeekDay
instance GHC.Enum.Bounded Data.SpreadSheet.Date.WeekDay
instance GHC.Classes.Ord Data.SpreadSheet.Date.WeekDay
instance GHC.Classes.Eq Data.SpreadSheet.Date.WeekDay
instance GHC.Show.Show Data.SpreadSheet.Date.WeekDay
instance GHC.Read.Read Data.SpreadSheet.Date.Month
instance GHC.Arr.Ix Data.SpreadSheet.Date.Month
instance GHC.Enum.Bounded Data.SpreadSheet.Date.Month
instance GHC.Classes.Ord Data.SpreadSheet.Date.Month
instance GHC.Classes.Eq Data.SpreadSheet.Date.Month
instance GHC.Show.Show Data.SpreadSheet.Date.Month
instance GHC.Enum.Enum Data.SpreadSheet.Date.WeekDay
instance GHC.Enum.Enum Data.SpreadSheet.Date.Month
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Time.Calendar.Days.Day


-- | Módulo interno que define una forma más visual de representar una hoja
--   de cálculo de forma textual.
--   
--   Ofrece una alternativa a la función <a>show</a> para redefinir la
--   visualización de una hoja de cáluclo (<a>SpreadSheet</a>).
--   
--   Este módulo es *unsafe* al aprovechar la función <a>show</a> de
--   <a>Matrix</a>.
--   
--   Para poder usar de forma efectiva este módulo, se tendrá que definir
--   una implementación de la clase <a>Celldable</a>, indicando la
--   representación del valor vacío.
--   
--   Ante la uniformidad de las hojas de cálculo (<a>SpreadSheet</a>
--   <tt>a</tt>, <a>SpreadSheet</a> <a>Double</a>) algunas de estas celdas
--   pueden no tener valor. Esto no supone un problema para trabajar con
--   ellas, salvo cuando queremos representar todo el conjuto de celdas que
--   engloba el rango de una hoja.
--   
--   <h2>Ejemplo de visualización</h2>
--   
--   Para visualizar por ejemplo una hoja de cálculo de números
--   (<a>SpreadSheet</a> <a>Double</a>) no tenemos un valor <a>Double</a>
--   para las celdas vacías. La visualización por tanto, no sería posible.
--   Si a pesar de esto queremos visualizar dicha hoja de cálculo, se
--   deberá indicar con qué valor <a>Double</a> se representará la celda
--   vacía. Este valor se indica instancianddo la clase <a>Celldable</a>.
--   
--   Tomamos por ejemplo el valor <tt>0</tt>:
--   
--   <pre>
--   instance Celldable Double where
--     blank = 0
--   </pre>
--   
--   <i>Esto no quiere decir que las celdas tengan valor 0, sino que</i>
--   <i>se visualizan como 0.</i>
--   
--   Si se quiere usar esta función para la visualización por defecto, se
--   recomienda que tras instanciar <a>Celldable</a> se realice la
--   sobreescritura de la clase <a>Show</a>:
--   
--   <pre>
--   instance {-# OVERLAPS -#} Show (SpreadSheet Double) where
--     show = prettyShowSpreadSheet
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [((1,1), 1),((2,3), 3)] :: SpreadSheet Double
--   Range (1,1) (2,3)
--   ┌          ┐
--   │ 1.0  0.0 │
--   │ 0.0  0.0 │
--   │ 0.0  3.0 │
--   └          ┘
--   </pre>
module Data.SpreadSheet.Internal.Pretty

-- | Clase para indicar el valor con el que se representarán las celdas
--   vacías.
class Celldable a
blank :: Celldable a => a

-- | Función alternativa para representar una hoja de cálculo.
prettyShowSpreadSheet :: (Show a, Celldable a) => SpreadSheet a -> String


-- | Este módulo permita una utilización más convencional de las hojas de
--   cálculo. Ofrece el tipo de datos necesario para poder tener valores
--   heterogéneos (de distinto tipo) sobre cada celda.
module Data.SpreadSheet.Cell

-- | El tipo de dato <a>Cell</a> es la suma de los tipos <a>Double</a>,
--   <a>String</a>, <a>Day</a> y <a>Bool</a>. Además, se añade el valor
--   <a>Blank</a> para poder explicitar celdas vacías. Las hojas de cálculo
--   que se crearían serían del tipo <a>SpreadSheet</a> <a>Cell</a>.
--   
--   Si queremos trabajar con los valores básicos de cada celda se puede
--   definir una función sobre el dominio de <a>Cell</a> o bien extraer el
--   propio valor. Para hacer esto último se ofrece la familia de funciones
--   <tt>extract</tt>, como por ejemplo <a>extractDouble</a>. Estas
--   funciones generarían una hoja de cálculo homogenea con solo las celdas
--   que sean del tipo correspondiente. <i>(Ejemplos en la definición de
--   estas funciones)</i>.
--   
--   Se ofrecen también las funciones para generar tipos complejos de datos
--   a partir de conjuntos de celdas con la clase <tt>ComplexCell</tt> y
--   las funciones <tt>toCell</tt> y <tt>fromCells</tt>.
data Cell
CNumber :: Double -> Cell
CString :: String -> Cell

-- | Se ofrece el módulo <a>Date</a> con ciertas funciones para facilitar
--   operaciones con fechas.
CDay :: Day -> Cell
CBool :: Bool -> Cell
Blank :: Cell

-- | Se restringe la función <a>put</a> para solo valores de <a>Cell</a>.
--   Además, permite incluir directamente funciones de <tt>SpreadSheet Cell
--   -&gt; a</tt> siempre que <tt>a</tt> pueda ser un valor en <a>Cell</a>.
--   
--   <pre>
--   &gt;&gt;&gt; put (1,1) (const $ CString "valor") empty
--   Range (1,1) (1,1)
--   ┌         ┐
--   │ "valor" │
--   └         ┘
--   
--   &gt;&gt;&gt; putCell (1,1) (const "valor") empty
--   Range (1,1) (1,1)
--   ┌         ┐
--   │ "valor" │
--   └         ┘
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let cells = fromList [((1,1), CBool True), ((1,2), CBool False)]
--   
--   &gt;&gt;&gt; put (2,1) (CNumber . fromIntegral . length) (column 1 cells)
--   ┌             ┐
--   │  True   2.0 │
--   │ False     ■ │
--   └             ┘
--   
--   &gt;&gt;&gt; putCell (2,1) (fromIntegral . length) (column 1 cells)
--   Range (1,1) (2,2)
--   ┌             ┐
--   │  True   2.0 │
--   │ False     ■ │
--   └             ┘
--   </pre>
putCell :: CCell a => Pos -> (SpreadSheet Cell -> a) -> SpreadSheet Cell -> SpreadSheet Cell

extractDouble :: SpreadSheet Cell -> SpreadSheet Double

extractString :: SpreadSheet Cell -> SpreadSheet String

extractDay :: SpreadSheet Cell -> SpreadSheet Day

extractBool :: SpreadSheet Cell -> SpreadSheet Bool

-- | Conjuntos de celdas se pueden representar atributos de otros datos
--   compuestos. Mediante la implementación de esta clase se ofrecen
--   herramientas para componer y descomponer conjuntos de datos.
class CompositeCell a

-- | El númmero de celdas necesarias para representar un dato <tt>a</tt>
--   puede variar, por eso siempre se toma como parámetro para indicar el
--   tamaño.
--   
--   <pre>
--   data Localización = Coordenada { lat :: Double, lon :: Double }
--                     | Dirección { calle :: String, número :: Int,
--                                   ciudad :: String
--                                 }
--   </pre>
--   
--   Para el caso de una <tt>Localización</tt> podríamos tener distintas
--   formas de representarla, y por tanto, varios tamaños.
--   
--   <pre>
--   &gt;&gt;&gt; size $ Coordenada 40.404823 -3.839532
--   2
--   
--   &gt;&gt;&gt; size $ Dirección "Avd. de los Ciruelos" 0 "Boadilla del Monte"
--   3
--   </pre>
size :: CompositeCell a => a -> Natural
buildCell :: CompositeCell a => a -> [Cell]
buildComposite :: CompositeCell a => [Cell] -> Maybe a

-- | Para la construcción de tipos complejos es necesario indicar la
--   orientación de datos.
--   
--   Si por ejemplo se desea constuir un tipo complejo como es
--   <tt>Expense</tt>:
--   
--   <pre>
--   data Expense = { concepto :: String, coste :: Double, fecha :: Day }
--   </pre>
--   
--   Los datos pueden estar dispuestos de dos formas diferentes:
--   
--   <b>1</b> Horizontal:
--   
--   <pre>
--   ┌                                  ┐
--   │ "Concepto"    "Coste"    "Fecha" │
--   │     "Agua"        1.0 2018-10-10 │
--   │     "Zumo"        2.0 2018-10-10 │
--   └                                  ┘
--   </pre>
--   
--   <b>2</b> Vertical:
--   
--   <pre>
--   ┌                                  ┐
--   │ "Concepto"     "Agua"     "Zumo" │
--   │ "Coste"           1.0        2.0 │
--   │ "Fecha"    2018-10-10 2018-10-10 │
--   └                                  ┘
--   </pre>
data Align
Horizontal :: Align
Vertical :: Align

-- | Transforma un dato complejo a un conjunto de celdas. La orientación se
--   representa como en <a>Align</a>.
--   
--   Es necesario que estos datos implementen la clase <a>CompositeCell</a>
toCellAlign :: CompositeCell a => Align -> Pos -> [a] -> SpreadSheet Cell

-- | Obtiene posibles datos complejos de un conjunto de celdas.
fromCellAlign :: CompositeCell a => Align -> SpreadSheet Cell -> [Maybe a]
instance GHC.Classes.Eq Data.SpreadSheet.Cell.Align
instance GHC.Show.Show Data.SpreadSheet.Cell.Align
instance GHC.Classes.Eq Data.SpreadSheet.Cell.Cell
instance Data.SpreadSheet.Cell.CCell Data.Time.Calendar.Days.Day
instance Data.SpreadSheet.Cell.CCell GHC.Types.Double
instance Data.SpreadSheet.Cell.CCell GHC.Base.String
instance Data.SpreadSheet.Cell.CCell GHC.Types.Bool
instance GHC.Show.Show Data.SpreadSheet.Cell.Cell
instance Data.SpreadSheet.Internal.Pretty.Celldable Data.SpreadSheet.Cell.Cell
instance GHC.Show.Show (Data.SpreadSheet.SpreadSheet Data.SpreadSheet.Cell.Cell)
